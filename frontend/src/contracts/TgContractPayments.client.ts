/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.13.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/
// @ts-nocheck

import { ICosmWasmClient, ISigningCosmWasmClient } from "./baseClient";
import { StdFee } from "@interchainjs/types";
import { Auth, InstantiateMsg, ExecuteMsg, CustomExecuteMsg, Uint256, ServiceHandlerExecuteMessages, WavsEnvelope, Binary, HexBinary, EvmAddr, RegisterReceiveMsg, SendPaymentMsg, WavsSignatureData, QueryMsg, CustomQueryMsg, ServiceHandlerQueryMessages, ChainAddrResponse, AdminResponse, ArrayOfString, ArrayOfCoin, Coin, TgHandleResponse, Addr } from "./TgContractPayments.types";
export interface TgContractPaymentsReadOnlyInterface {
  contractAddress: string;
  addrByTg: ({
    handle
  }: {
    handle: string;
  }) => Promise<ChainAddrResponse>;
  tgByAddr: ({
    account
  }: {
    account: string;
  }) => Promise<TgHandleResponse>;
  admin: () => Promise<AdminResponse>;
  pendingPayments: ({
    handle
  }: {
    handle: string;
  }) => Promise<ArrayOfCoin>;
  allowedDenoms: () => Promise<ArrayOfString>;
  wavsServiceManager: () => Promise<Addr>;
}
export class TgContractPaymentsQueryClient implements TgContractPaymentsReadOnlyInterface {
  client: ICosmWasmClient;
  contractAddress: string;
  constructor(client: ICosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.addrByTg = this.addrByTg.bind(this);
    this.tgByAddr = this.tgByAddr.bind(this);
    this.admin = this.admin.bind(this);
    this.pendingPayments = this.pendingPayments.bind(this);
    this.allowedDenoms = this.allowedDenoms.bind(this);
    this.wavsServiceManager = this.wavsServiceManager.bind(this);
  }
  addrByTg = async ({
    handle
  }: {
    handle: string;
  }): Promise<ChainAddrResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      addr_by_tg: {
        handle
      }
    });
  };
  tgByAddr = async ({
    account
  }: {
    account: string;
  }): Promise<TgHandleResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      tg_by_addr: {
        account
      }
    });
  };
  admin = async (): Promise<AdminResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      admin: {}
    });
  };
  pendingPayments = async ({
    handle
  }: {
    handle: string;
  }): Promise<ArrayOfCoin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pending_payments: {
        handle
      }
    });
  };
  allowedDenoms = async (): Promise<ArrayOfString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      allowed_denoms: {}
    });
  };
  wavsServiceManager = async (): Promise<Addr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      wavs_service_manager: {}
    });
  };
}
export interface TgContractPaymentsInterface extends TgContractPaymentsReadOnlyInterface {
  contractAddress: string;
  sender: string;
  registerReceive: ({
    chainAddr,
    tgHandle
  }: {
    chainAddr: string;
    tgHandle: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  sendPayment: ({
    amount,
    denom,
    fromTg,
    toTg
  }: {
    amount: Uint256;
    denom: string;
    fromTg: string;
    toTg: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  registerSend: ({
    tgHandle
  }: {
    tgHandle: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
  wavsHandleSignedEnvelope: ({
    envelope,
    signatureData
  }: {
    envelope: WavsEnvelope;
    signatureData: WavsSignatureData;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<any>;
}
export class TgContractPaymentsClient extends TgContractPaymentsQueryClient implements TgContractPaymentsInterface {
  client: ISigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: ISigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.registerReceive = this.registerReceive.bind(this);
    this.sendPayment = this.sendPayment.bind(this);
    this.registerSend = this.registerSend.bind(this);
    this.wavsHandleSignedEnvelope = this.wavsHandleSignedEnvelope.bind(this);
  }
  registerReceive = async ({
    chainAddr,
    tgHandle
  }: {
    chainAddr: string;
    tgHandle: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      register_receive: {
        chain_addr: chainAddr,
        tg_handle: tgHandle
      }
    }, fee_, memo_, funds_);
  };
  sendPayment = async ({
    amount,
    denom,
    fromTg,
    toTg
  }: {
    amount: Uint256;
    denom: string;
    fromTg: string;
    toTg: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_payment: {
        amount,
        denom,
        from_tg: fromTg,
        to_tg: toTg
      }
    }, fee_, memo_, funds_);
  };
  registerSend = async ({
    tgHandle
  }: {
    tgHandle: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      register_send: {
        tg_handle: tgHandle
      }
    }, fee_, memo_, funds_);
  };
  wavsHandleSignedEnvelope = async ({
    envelope,
    signatureData
  }: {
    envelope: WavsEnvelope;
    signatureData: WavsSignatureData;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<any> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      wavs_handle_signed_envelope: {
        envelope,
        signature_data: signatureData
      }
    }, fee_, memo_, funds_);
  };
}