/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/ban-ts-comment */
/**
 * This file was automatically generated by @cosmwasm/ts-codegen@1.13.3.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */
// @ts-nocheck

import type {
  ICosmWasmClient,
  ISigningCosmWasmClient,
  StdFee,
  Coin as BaseCoin,
} from "./baseClient";
import type {
  Uint256,
  ServiceHandlerExecuteMessages,
  ServiceHandlerQueryMessages,
  ChainAddrResponse,
  ArrayOfString,
  ArrayOfCoin,
  Coin,
  TgHandleResponse,
  Null,
} from "./TgContractPayments.types";
export interface TgContractPaymentsReadOnlyInterface {
  contractAddress: string;
  addrByTg: ({ handle }: { handle: string }) => Promise<ChainAddrResponse>;
  tgByAddr: ({ account }: { account: string }) => Promise<TgHandleResponse>;
  admin: () => Promise<any>;
  pendingPayments: ({ handle }: { handle: string }) => Promise<ArrayOfCoin>;
  allowedDenoms: () => Promise<ArrayOfString>;
  wavs: (
    serviceHandlerQueryMessages: ServiceHandlerQueryMessages
  ) => Promise<Null>;
}
export class TgContractPaymentsQueryClient
  implements TgContractPaymentsReadOnlyInterface
{
  client: ICosmWasmClient;
  contractAddress: string;
  constructor(client: ICosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.addrByTg = this.addrByTg.bind(this);
    this.tgByAddr = this.tgByAddr.bind(this);
    this.admin = this.admin.bind(this);
    this.pendingPayments = this.pendingPayments.bind(this);
    this.allowedDenoms = this.allowedDenoms.bind(this);
    this.wavs = this.wavs.bind(this);
  }
  addrByTg = async ({
    handle,
  }: {
    handle: string;
  }): Promise<ChainAddrResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      addr_by_tg: {
        handle,
      },
    });
  };
  tgByAddr = async ({
    account,
  }: {
    account: string;
  }): Promise<TgHandleResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      tg_by_addr: {
        account,
      },
    });
  };
  admin = async (): Promise<AdminResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      admin: {},
    });
  };
  pendingPayments = async ({
    handle,
  }: {
    handle: string;
  }): Promise<ArrayOfCoin> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pending_payments: {
        handle,
      },
    });
  };
  allowedDenoms = async (): Promise<ArrayOfString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      allowed_denoms: {},
    });
  };
  wavs = async (
    serviceHandlerQueryMessages: ServiceHandlerQueryMessages
  ): Promise<Null> => {
    return this.client.queryContractSmart(this.contractAddress, {
      wavs: serviceHandlerQueryMessages,
    });
  };
}
export interface TgContractPaymentsInterface
  extends TgContractPaymentsReadOnlyInterface {
  contractAddress: string;
  sender: string;
  registerReceive: (
    {
      chainAddr,
      tgHandle,
    }: {
      chainAddr: string;
      tgHandle: string;
    },
    fee_?: number | StdFee | "auto",
    memo_?: string,
    funds_?: BaseCoin[]
  ) => Promise<any>;
  sendPayment: (
    {
      amount,
      denom,
      fromTg,
      toTg,
    }: {
      amount: Uint256;
      denom: string;
      fromTg: string;
      toTg: string;
    },
    fee_?: number | StdFee | "auto",
    memo_?: string,
    funds_?: BaseCoin[]
  ) => Promise<any>;
  registerSend: (
    {
      tgHandle,
    }: {
      tgHandle: string;
    },
    fee_?: number | StdFee | "auto",
    memo_?: string,
    funds_?: BaseCoin[]
  ) => Promise<any>;
  wavs: (
    serviceHandlerExecuteMessages: ServiceHandlerExecuteMessages,
    fee_?: number | StdFee | "auto",
    memo_?: string,
    funds_?: BaseCoin[]
  ) => Promise<any>;
}
export class TgContractPaymentsClient
  extends TgContractPaymentsQueryClient
  implements TgContractPaymentsInterface
{
  client: ISigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(
    client: ISigningCosmWasmClient,
    sender: string,
    contractAddress: string
  ) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.registerReceive = this.registerReceive.bind(this);
    this.sendPayment = this.sendPayment.bind(this);
    this.registerSend = this.registerSend.bind(this);
    this.wavs = this.wavs.bind(this);
  }
  registerReceive = async (
    {
      chainAddr,
      tgHandle,
    }: {
      chainAddr: string;
      tgHandle: string;
    },
    fee_: number | StdFee | "auto" = "auto",
    memo_?: string,
    funds_?: Coin[]
  ): Promise<any> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        register_receive: {
          chain_addr: chainAddr,
          tg_handle: tgHandle,
        },
      },
      fee_,
      memo_,
      funds_
    );
  };
  sendPayment = async (
    {
      amount,
      denom,
      fromTg,
      toTg,
    }: {
      amount: Uint256;
      denom: string;
      fromTg: string;
      toTg: string;
    },
    fee_: number | StdFee | "auto" = "auto",
    memo_?: string,
    funds_?: Coin[]
  ): Promise<any> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        send_payment: {
          amount,
          denom,
          from_tg: fromTg,
          to_tg: toTg,
        },
      },
      fee_,
      memo_,
      funds_
    );
  };
  registerSend = async (
    {
      tgHandle,
    }: {
      tgHandle: string;
    },
    fee_: number | StdFee | "auto" = "auto",
    memo_?: string,
    funds_?: Coin[]
  ): Promise<any> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        register_send: {
          tg_handle: tgHandle,
        },
      },
      fee_,
      memo_,
      funds_
    );
  };
  wavs = async (
    serviceHandlerExecuteMessages: ServiceHandlerExecuteMessages,
    fee_: number | StdFee | "auto" = "auto",
    memo_?: string,
    funds_?: Coin[]
  ): Promise<any> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        wavs: serviceHandlerExecuteMessages,
      },
      fee_,
      memo_,
      funds_
    );
  };
}
