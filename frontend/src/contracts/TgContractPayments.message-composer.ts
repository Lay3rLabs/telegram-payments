/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.13.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { EncodeObject } from "@interchainjs/cosmos-types";
import { MsgExecuteContract } from "interchainjs/cosmwasm/wasm/v1/tx";
import { toUtf8 } from "@interchainjs/encoding";
import { Auth, InstantiateMsg, ExecuteMsg, Uint256, ServiceHandlerExecuteMessages, WavsEnvelope, Binary, HexBinary, EvmAddr, RegisterReceiveMsg, SendPaymentMsg, WavsSignatureData, QueryMsg, ServiceHandlerQueryMessages, ChainAddrResponse, AdminResponse, ArrayOfString, ArrayOfCoin, Coin, TgHandleResponse, Null } from "./TgContractPayments.types";
export interface TgContractPaymentsMsg {
  contractAddress: string;
  sender: string;
  registerReceive: ({
    chainAddr,
    tgHandle
  }: {
    chainAddr: string;
    tgHandle: string;
  }, funds_?: Coin[]) => EncodeObject;
  sendPayment: ({
    amount,
    denom,
    fromTg,
    toTg
  }: {
    amount: Uint256;
    denom: string;
    fromTg: string;
    toTg: string;
  }, funds_?: Coin[]) => EncodeObject;
  registerSend: ({
    tgHandle
  }: {
    tgHandle: string;
  }, funds_?: Coin[]) => EncodeObject;
  wavs: (serviceHandlerExecuteMessages: ServiceHandlerExecuteMessages, funds_?: Coin[]) => EncodeObject;
}
export class TgContractPaymentsMsgComposer implements TgContractPaymentsMsg {
  sender: string;
  contractAddress: string;
  constructor(sender: string, contractAddress: string) {
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.registerReceive = this.registerReceive.bind(this);
    this.sendPayment = this.sendPayment.bind(this);
    this.registerSend = this.registerSend.bind(this);
    this.wavs = this.wavs.bind(this);
  }
  registerReceive = ({
    chainAddr,
    tgHandle
  }: {
    chainAddr: string;
    tgHandle: string;
  }, funds_?: Coin[]): EncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          register_receive: {
            chain_addr: chainAddr,
            tg_handle: tgHandle
          }
        })),
        funds: funds_
      })
    };
  };
  sendPayment = ({
    amount,
    denom,
    fromTg,
    toTg
  }: {
    amount: Uint256;
    denom: string;
    fromTg: string;
    toTg: string;
  }, funds_?: Coin[]): EncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          send_payment: {
            amount,
            denom,
            from_tg: fromTg,
            to_tg: toTg
          }
        })),
        funds: funds_
      })
    };
  };
  registerSend = ({
    tgHandle
  }: {
    tgHandle: string;
  }, funds_?: Coin[]): EncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          register_send: {
            tg_handle: tgHandle
          }
        })),
        funds: funds_
      })
    };
  };
  wavs = (serviceHandlerExecuteMessages: ServiceHandlerExecuteMessages, funds_?: Coin[]): EncodeObject => {
    return {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      value: MsgExecuteContract.fromPartial({
        sender: this.sender,
        contract: this.contractAddress,
        msg: toUtf8(JSON.stringify({
          wavs: serviceHandlerExecuteMessages
        })),
        funds: funds_
      })
    };
  };
}