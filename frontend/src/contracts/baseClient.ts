/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.13.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/
// @ts-nocheck


// @ts-nocheck - Generated file with type issues
import type { DirectSigner } from '@interchainjs/cosmos';
import { getSmartContractState } from 'interchainjs/cosmwasm/wasm/v1/query.rpc.func';
import { executeContract } from 'interchainjs/cosmwasm/wasm/v1/tx.rpc.func';
import type { QuerySmartContractStateRequest, QuerySmartContractStateResponse } from 'interchainjs/cosmwasm/wasm/v1/query';
import type { MsgExecuteContract } from 'interchainjs/cosmwasm/wasm/v1/tx';
import { GasPrice } from '@cosmjs/stargate';
import { SigningCosmWasmClient } from '@cosmjs/cosmwasm-stargate';
import type { OfflineDirectSigner } from '@cosmjs/proto-signing';

// Define types that might not be exported properly
export type StdFee = {
  amount: Array<{ denom: string; amount: string }>;
  gas: string;
};

export type Coin = {
  denom: string;
  amount: string;
};

export type Chain = any; // Use any for now since the import is broken

// Encoding utility functions
const fromUint8Array = <T>(uint8Array: Uint8Array): T => {
  const text = new TextDecoder().decode(uint8Array);
  return JSON.parse(text);
};

const toUint8Array = (obj: any): Uint8Array => {
  const text = JSON.stringify(obj);
  return new TextEncoder().encode(text);
};

// Chain registry configuration
// The amount under gasPrice represents gas price per unit
export interface ChainConfig {
  chain?: any; // Chain type from registry
  gasPrice?: {
    denom: string;
    amount: string;
  };
}

// Gas fee calculation utilities
export const calculateGasFromChain = (chain: any, gasAmount: string): StdFee => {
  try {
    const feeTokens = chain.fees?.feeTokens;
    
    if (feeTokens && feeTokens.length > 0) {
      const primaryToken = feeTokens[0];
      // v2 chain-registry uses camelCase: averageGasPrice, lowGasPrice, fixedMinGasPrice
      const gasPrice = primaryToken.averageGasPrice || primaryToken.lowGasPrice || primaryToken.fixedMinGasPrice || 0.025;
      const gasAmountNum = parseInt(gasAmount);
      const feeAmount = Math.ceil(gasAmountNum * gasPrice).toString();
      
      return {
        amount: [{
          denom: primaryToken.denom,
          amount: feeAmount
        }],
        gas: gasAmount
      };
    }
  } catch (error) {
    console.warn('Failed to calculate gas from chain registry:', error);
  }
  
  // Fallback to default
  return { amount: [], gas: gasAmount };
};

// Default gas amount - users can easily change this
export let DEFAULT_GAS_AMOUNT = '200000';

// Allow users to set their preferred default gas amount
export const setDefaultGasAmount = (gasAmount: string): void => {
  DEFAULT_GAS_AMOUNT = gasAmount;
};

// Get current default gas amount
export const getDefaultGasAmount = (): string => DEFAULT_GAS_AMOUNT;

export const getAutoGasFee = (chainConfig?: ChainConfig): StdFee => {
  const gasAmount = DEFAULT_GAS_AMOUNT;
  
  if (chainConfig?.chain) {
    return calculateGasFromChain(chainConfig.chain, gasAmount);
  }
  
  if (chainConfig?.gasPrice) {
    const gasAmountNum = parseInt(gasAmount);
    const gasPriceNum = parseFloat(chainConfig.gasPrice.amount);
    const feeAmount = Math.ceil(gasAmountNum * gasPriceNum).toString();
    
    return {
      amount: [{
        denom: chainConfig.gasPrice.denom,
        amount: feeAmount
      }],
      gas: gasAmount
    };
  }
  
  // Fallback: no fee tokens, just gas amount
  return { amount: [], gas: gasAmount };
};

// InterchainJS interfaces for CosmWasm clients
export interface ICosmWasmClient {
  queryContractSmart(contractAddr: string, query: any): Promise<any>;
}

export interface ISigningCosmWasmClient extends ICosmWasmClient {
  execute(
    sender: string,
    contractAddress: string,
    msg: any,
    fee?: number | StdFee | "auto",
    memo?: string,
    funds?: Coin[],
    chainConfig?: ChainConfig
  ): Promise<any>;

  signAndBroadcast(
    signerAddress: string,
    messages: any[],
    fee: number | StdFee | "auto",
    memo?: string
  ): Promise<any>;
}

export interface ISigningClient {
  signAndBroadcast(
    signerAddress: string,
    messages: any[],
    fee: number | StdFee | "auto",
    memo?: string
  ): Promise<any>;
}

// Helper functions to create InterchainJS clients
export function getCosmWasmClient(rpcEndpoint: string): ICosmWasmClient {
  return {
    queryContractSmart: async (contractAddr: string, query: any) => {
      // Create the request object
      const request: QuerySmartContractStateRequest = {
        address: contractAddr,
        queryData: toUint8Array(query)
      };
      
      // Execute the query using InterchainJS
      const response: QuerySmartContractStateResponse = await getSmartContractState(rpcEndpoint, request);
      
      // Parse and return the result
      return fromUint8Array(response.data);
    },
  };
}

export function getSigningCosmWasmClient(signingClient: DirectSigner, rpcEndpoint?: string): ISigningCosmWasmClient {
  // Create a SigningCosmWasmClient wrapper that has signAndBroadcast
  let cosmwasmClient: SigningCosmWasmClient | null = null;

  const getCosmWasmClient = async (): Promise<SigningCosmWasmClient> => {
    if (!cosmwasmClient) {
      if (!rpcEndpoint) {
        throw new Error('rpcEndpoint is required for signing operations');
      }
      // Set gas price for Neutron (0.025untrn is a reasonable default)
      const gasPrice = GasPrice.fromString('0.025untrn');
      cosmwasmClient = await SigningCosmWasmClient.connectWithSigner(
        rpcEndpoint,
        signingClient as unknown as OfflineDirectSigner,
        { gasPrice }
      );
    }
    return cosmwasmClient;
  };

  return {
    queryContractSmart: async (contractAddr: string, query: any) => {
      if (!rpcEndpoint) {
        throw new Error('rpcEndpoint is required for queryContractSmart in signing client');
      }
      const request: QuerySmartContractStateRequest = {
        address: contractAddr,
        queryData: toUint8Array(query)
      };
      const response: QuerySmartContractStateResponse = await getSmartContractState(rpcEndpoint, request);
      return fromUint8Array(response.data);
    },

    signAndBroadcast: async (signerAddress: string, messages: any[], fee: number | StdFee | "auto", memo?: string) => {
      // Get the SigningCosmWasmClient which has signAndBroadcast
      const client = await getCosmWasmClient();
      return await client.signAndBroadcast(signerAddress, messages, fee as any, memo);
    },
    execute: async (
      sender: string, 
      contractAddress: string, 
      msg: any, 
      fee?: number | StdFee | "auto", 
      memo?: string, 
      funds?: Coin[], 
      chainConfig?: ChainConfig
    ) => {
      // Handle fee conversion
      let finalFee: StdFee;
      if (typeof fee === 'number') {
        finalFee = { amount: [], gas: fee.toString() };
      } else if (fee === 'auto') {
        finalFee = getAutoGasFee(chainConfig);
      } else if (fee) {
        finalFee = fee;
      } else {
        finalFee = getAutoGasFee(chainConfig);
      }

      // Create the message object
      const message: MsgExecuteContract = {
        sender,
        contract: contractAddress,
        msg: toUint8Array(msg),
        funds: funds || []
      };
      
      // Execute the transaction using InterchainJS
      const result = await executeContract(
        signingClient as any,
        sender,
        message,
        finalFee,
        memo || ''
      );
      
      return result;
    },
  };
}
